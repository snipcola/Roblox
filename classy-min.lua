local assert=assert;local a=assert(_VERSION)local setmetatable=assert(setmetatable)local select=assert(select)local pairs=assert(pairs)local ipairs=assert(ipairs)local type=assert(type)local error=assert(error)local load=assert(load)local b=assert(string.rep)local c=assert(a=="Lua 5.1"and unpack or table.unpack)local d={__add=true,__sub=true,__mul=true,__div=true,__mod=true,__pow=true,__unm=true,__concat=true,__len=true,__eq=true,__lt=true,__le=true,__call=true,__tostring=true,__pairs=true,__ipairs=true,__gc=true,__newindex=true,__metatable=true,__idiv=true,__band=true,__bor=true,__bxor=true,__bnot=true,__shl=true,__shr=true,__close=true}local e={__mode="k"}local f=setmetatable({},e)local function g(h)return function()return setmetatable({},h)end end;local function i(h,j)return function(k,...)local l=setmetatable({},h)j(l,...)return l end end;local function m(n,o)local p=f[n]if p.members[o]~=nil then p.o_meta.__index[o]=p.members[o]else for q=1,#p.super do local r=f[p.super[q]].members[o]if r~=nil then p.o_meta.__index[o]=r;return end end;p.o_meta.__index[o]=nil end end;local function s(n,o,r)local p=f[n]if d[o]then assert(p.o_meta[o]==nil,"overwriting metamethods not allowed")p.o_meta[o]=r;p.members[o]=r;m(n,o)for t in pairs(p.sub)do m(t,o)end elseif o=="__init"then p.members.__init=r;p.o_meta.__index.__init=r;if type(r)=="function"then p.c_meta.__call=i(p.o_meta,r)else p.c_meta.__call=g(p.o_meta)end else assert(o~="__class","key '__class' is reserved")p.members[o]=r;m(n,o)for t in pairs(p.sub)do m(t,o)end end end;local function u(n)return pairs(f[n].o_meta.__index)end;local function v(n)return ipairs(f[n].o_meta.__index)end;local function w(n,x,...)local y=select('#',...)for q=1,y do local z=select(q,...)assert(f[z],"invalid class")x[q]=z end;x.n=y;local A,B=1,y;for q,C in ipairs(x)do local D=f[C]local E,F=D.super,D.sub;if not F[n]then F[n]=A end;for q=1,E.n do x[#x+1]=E[q]end;B=B+E.n;if q==y then y,A=B,A+1 end end end;local function G(k,H,...)assert(type(H)=="string","class name must be a string")local n,I={},{}local J={__index=I,__name=H}local p={name=H,super={n=0},sub=setmetatable({},e),members={},o_meta=J,c_meta={__index=I,__newindex=s,__call=g(J),__pairs=u,__ipairs=v,__name="class",__metatable=false}}w(n,p.super,...)for q=#p.super,1,-1 do for K,L in pairs(f[p.super[q]].members)do if K~="__init"then I[K]=L end end end;I.__class=n;f[n]=p;return setmetatable(n,p.c_meta)end;local M={}setmetatable(M,{__call=G})function M.of(l)return type(l)=="table"and l.__class or nil end;function M.name(N)if N==nil then return nil end;N=type(N)=="table"and N.__class or N;local p=f[N]return p and p.name end;function M.is_a(N,n)if N==nil then return nil end;local p=assert(f[n],"invalid class")N=type(N)=="table"and N.__class or N;if N==n then return 0 end;return p.sub[N]end;function M.cast(l,O)local p=f[O]if not p then error("invalid class")end;setmetatable(l,p.o_meta)return l end;local function P(n,Q,R)n[R]=function(self,...)local S=self[Q]return S[R](S,...)end end;function M.delegate(n,T,...)if type(...)=="table"then for K,L in pairs(...)do if n[K]==nil and K~="__init"and type(L)=="function"then P(n,T,K)end end else for q=1,select('#',...)do local K=select(q,...)if n[K]==nil and K~="__init"then P(n,T,K)end end end;return n end;do local U=setmetatable({},e)local V=0;if a=="Lua 5.1"then V=1 end;local function W()error("no matching multimethod overload",2+V)end;local function X()error("no matching multimethod overload",3+V)end;local function Y()error("ambiguous multimethod call",3+V)end;local Z={}local _=4;function M.multimethod(...)local a0,y={...},select('#',...)assert(y>=1,"no polymorphic parameter for multimethod")local a1=0;for q=1,y do local a2=a0[q]a1=assert(a2>a1 and a2%1==0 and a2,"invalid parameter overload specification")end;local a3={W,a0,a1}local function a4(...)return a3[1](a3,...)end;U[a4]=a3;return a4 end;local function a5()return setmetatable({},e)end;local function a6(a7,...)local a8=0;for q=1,select('#',...)do local a9,aa=a7[q],select(q,...)if type(a9)=="table"then local p=f[a9]local A=aa==a9 and 0 or p and p.sub[aa]if not A then return nil end;a8=a8+A else if aa~=a9 then return nil end end end;return a8 end;local function ab(ac,ad,ae,a7,...)local a8=a6(a7,...)if a8 then if ac then if a8<ac then ac,ad,ae=a8,a7.func,false elseif a8==ac then ae=true end else ac,ad,ae=a8,a7.func,false end end;return ac,ad,ae end;local function af(a4,a9)local ag={},{}for q=_,#a4 do local a7=a4[q]for K,L in pairs(a7)do if type(K)=="function"and(a9==nil or L[a9])and not ag[K]then local ah=#ag+1;ag[ah]=K;ag[K]=ah end end end;return ag end;local function ai(a0,aj,ak)local y=#a0;if aj>=1 then a0[y+1]=ak;a0[y+2]=1 end;for q=2,aj do local ah=q*3+y;a0[ah-3]=","a0[ah-2]=ak;a0[ah-1]=q end end;local function al(a0,a4,ag,ah)local y,am=#a0,a4[2][ah]a0[y+1]="  t=type(_"a0[y+2]=am;a0[y+3]=")\n  local t"a0[y+4]=ah;a0[y+5]="=(t=='table' and _"a0[y+6]=am;a0[y+7]=".__class) or "local an=af(a4,ah)local aj=#an;for q=1,aj do local K=q*5+y+3;a0[K]="tc"a0[K+1]=ag[an[q]]a0[K+2]="(_"a0[K+3]=am;a0[K+4]=") or "end;a0[aj*5+y+8]="t\n"end;local function ao(a0,a4)local a8=#a4[2]local y=#a0;a0[y+1]=b("(",a8-1)a0[y+2]="cache"for q=1,a8-1 do local ah=q*3+y;a0[ah]="[t"a0[ah+1]=q;a0[ah+2]="] or empty)"end;local ah=a8*3+y;a0[ah]="[t"a0[ah+1]=a8;a0[ah+2]="]\n"end;local function ap(a0,q,ah)local y=#a0;a0[y+1]="    cost,f,is_amb=sel_impl(cost,f,is_amb,mm["a0[y+2]=ah+_-1;a0[y+3]="],"ai(a0,q,"t")a0[#a0+1]=")\n"end;local function aq(a0,q)local y=#a0;a0[y+1]="    if not t[t"a0[y+2]=q;a0[y+3]="] then t[t"a0[y+4]=q;a0[y+5]="]=mk_weak() end\n    t=t[t"a0[y+6]=q;a0[y+7]="]\n"end;local function ar(a4,...)local y=#a4[2]local as=af(a4)local at={"local type,cache,empty,mk_weak,sel_impl,no_match,amb_call"}if#as>=1 then at[#at+1]=","end;ai(at,#as,"tc")at[#at+1]="=...\nreturn function(mm,"ai(at,a4[3],"_")at[#at+1]=",...)\n  local t\n"for q=1,y do al(at,a4,as,q)end;at[#at+1]="  local f="ao(at,a4)at[#at+1]=[=[
